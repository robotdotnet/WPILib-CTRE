task downloadWpiUtil() {
    description = 'Downloads the C++ ARM wpiutil maven dependency.'
    group = 'WPILib'
    def depFolder = "$buildDir/dependencies"
    def utilZip = file("$depFolder/wpiutil.zip")
    outputs.file(utilZip)
    def armWpiUtil

    doFirst {
        def armWpiUtilDependency = project.dependencies.create("edu.wpi.first.wpilib:wpiutil:+:arm@zip")
        def armWpiUtilConfig = project.configurations.detachedConfiguration(armWpiUtilDependency)
        armWpiUtilConfig.setTransitive(false)
        armWpiUtil = armWpiUtilConfig.files[0].canonicalFile
    }

    doLast {
        copy {
            from armWpiUtil
            rename 'wpiutil(.+)', 'wpiutil.zip'
            into depFolder
        }
    }
}

def wpiUtilUnzipLocation = "$buildDir/wpiutil"

// Create a task that will unzip the wpiutil files into a temporary build directory
task unzipWpiUtil(type: Copy) {
    description = 'Unzips the wpiutil maven dependency so that the include files and libraries can be used'
    group = 'WPILib'
    dependsOn downloadWpiUtil

    from zipTree(downloadWpiUtil.outputs.files.singleFile)
    into wpiUtilUnzipLocation
}

ext.defineWpiUtilProperties = {
    ext.wpiUtil = wpiUtilUnzipLocation
    ext.wpiUtilInclude = "$wpiUtilUnzipLocation/include"
    ext.wpiUtilLibArmLocation = "$wpiUtilUnzipLocation/Linux/arm"
    ext.wpiUtilSharedLib = "$wpiUtilLibArmLocation/libwpiutil.so"
    ext.wpiUtilSharedLibDebug = "$wpiUtilLibArmLocation/libwpiutil.so.debug"
    ext.addWpiUtilLibraryLinks = { compileTask, linker, targetPlatform ->
        compileTask.dependsOn project(':').unzipWpiUtil
        String architecture = targetPlatform.architecture
        if (architecture.contains('arm')) {
            linker.args wpiUtilSharedLib
        }
    }
}


def halUnzipLocation = "$buildDir/hal"

task downloadHAL() {
    description = 'Downloads the C++ ARM HAL maven dependency.'

    group = 'WPILib'
    def depFolder = "$buildDir/dependencies"
    def libZip = file("$depFolder/hal.zip")
    outputs.file(libZip)
    def armHal
    

    doFirst {
        def armHALDependency = project.dependencies.create("edu.wpi.first.wpilib:hal:+@zip")
        def armHALConfig = project.configurations.detachedConfiguration(armHALDependency)
        armHALConfig.setTransitive(false)
        armHal = armHALConfig.files[0].canonicalFile
    }

    doLast {
        copy {
            from armHal
            rename 'hal(.+)', 'hal.zip'
            into depFolder
        }
    }
}

// Create a task that will unzip the hal files into a temporary build directory
task unzipHAL(type: Copy) {
    description = 'Unzips the hal maven dependency so that the include files and libraries can be used'
    group = 'WPILib'
    dependsOn downloadHAL
    
    from zipTree(downloadHAL.outputs.files.singleFile)
    into halUnzipLocation
}

ext.defineHALProperties = {
    ext.hal = halUnzipLocation
    ext.halInclude = "$halUnzipLocation/include"
    ext.halLocation = "$halUnzipLocation/lib"
    ext.halSharedLib = "$halLocation/libHALAthena.so"
  
    ext.addHalLibraryLinks = { compileTask, linker, targetPlatform ->
        compileTask.dependsOn project(':').unzipHAL
        String architecture = targetPlatform.architecture
        if (architecture.contains('arm')) {
            // Grab all the shared libraries and link them
            linker.args halSharedLib      
            linker.args "$halLocation/libnilibraries.so"

            def libraryPath = halLocation

            linker.args << '-L' + libraryPath
        }
    }
}

ext.addUserLinks = { linker, targetPlatform, implLib ->
    def libPattern = /.*((\\/|\\).*)+lib(?<libName>.+).(.+)$/
    def libraryArgs = []
    def libraryPath = file(driverLibraryLib).path

    // adds all libraries found in the driver folder
    def libraryTree = fileTree(libraryPath)
    libraryTree.include '*.so'
    libraryTree.include '*.a'

    libraryTree.each { lib ->
        def nameMatcher = (lib.path =~ libPattern)
        if (nameMatcher[0].size() > 1) {
            def name = nameMatcher.group('libName')
            libraryArgs << '-l' + name
        }
    }
     
    // Add all arguments
    String architecture = targetPlatform.architecture
    if (architecture.contains('arm')){
        linker.args << '-L' + libraryPath
        linker.args.addAll(libraryArgs)
    }
}
